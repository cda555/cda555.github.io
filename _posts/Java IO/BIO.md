# 介绍

BIO（Block IO）阻塞式IO。当调用*reda()*、*print()*方法时，会一直等待（阻塞）有数据到来，或者数据写出完成。当在等待时，线程什么都做不了。

# IO模型

### 1:1同步阻塞模型

有一个线程来监听连接，每到来一个连接就创建一个线程去处理。

![](D:\act\cda555.github.io\img\Java IO\1比1同步阻塞IO模型.png)

缺点：

- 服务端的线程数量与客户端数量是1：1的关系
- 随着客户端并发访问量的增大，服务端线程数量膨胀，性能急剧下降。



## M:N同步阻塞模型

使用线程池来处理连接的请求，每新到一个请求，就在线程池中获取一个线程来进行处理。

![](D:\act\cda555.github.io\img\Java IO\M比N形式的同步阻塞IO.png)

优点：

- 可以控制服务端线程数量，对服务端负载可控。
- 线程的复用

缺点：

- BIO的读和写都是阻塞的，阻塞的时间取决于对端IO线程的处理速度和网络IO的传输速度。
- 当线程池中的所有线程都因为对端IO线程处理速度慢导致阻塞时，所有后续接入的客户端连接请求都将在任务队列中排队堆积。

- 当所有线程都被占用后，新到来的连接只能等待，或者被拒绝，客户端会发生大量连接超时或失败。

